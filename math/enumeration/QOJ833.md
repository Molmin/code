先考虑堵一个格子的情形，把格子按照行号和列号的和分组，则在路径上每个不同的和的格子都正好经过一个。考虑求出最靠右下的路径和最靠左上的路径，一个格子若同时出现在两条路径中，则说明删掉后不存在路径。

考虑堵两个格子的情形。我们可以先堵掉一个同时在两条路径上的格子，再任意堵一个格子。如果先堵掉一个只在最左上的路径上的格子，则可以再求一次最左上的路径，再求新的最左上的路径和最右下的路径的交集。

考虑预处理能从 $(1,1)$ 到达且能到达 $(n,m)$ 的位置，然后堵掉一个格子之后最靠坐上的路径就变为找到和这个格子行号列号和相等的行号最大的，且满足从 $(1,1)$ 到达且能到达 $(n,m)$ 的格子。

时间复杂度 $\Theta\left((n+m)^2\right)$。
