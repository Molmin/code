容易发现能够构造出方案有两个必要条件：

- 两个序列首尾必须相同；
- 两个序列相邻两项组成的无序对构成的可重集合相同。

下面通过构造证明这也是充分的。

考虑同时对两个序列操作，最后两个序列相同，那么可以对第二个序列的操作反着操作一遍即可。从前往后每次遇到一个位置不同就尝试把其变为相同的，具体地，假设我们已经把前 $i-1$ 项变得相同，接下来要把第 $i$ 项变得相同：

- 如果能够找到一个 $j > i$ 使得 $a_j=a_{i-1}$ 且 $a_{j-1}=b_i$，则在 $a$ 上对区间 $[i-1,j]$ 操作即可；
- 如果能够找到一个 $j > i$ 使得 $b_j=b_{i-1}$ 且 $b_{j-1}=a_i$，则在 $b$ 上对区间 $[i-1,j]$ 操作即可；
- 由于『两个序列相邻两项组成的无序对构成的可重集合相同』成立，所以 $a$ 后面一定存在形如 $(x,a_{i-1})$ 的有序对（形如 $(a_{i-1},x)$ 的情况已经讨论过了），$b$ 中也同理。
  - 如果这两个 $x$ 相同，则都通过翻转把它们调整到第 $i$ 项即可；
  - 否则，一定存在另一组 $(x',a_{i-1})$（因为 $(x,a_{i-1})$ 也需要在另一个序列中找到对应的相邻数对），可以用归纳法证明最终一定会变为上面的情况。

时间复杂度 $O(\sum n^2)$，操作次数 $O(n)$。
