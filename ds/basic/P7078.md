首先有一个结论：如果最强的蛇吃掉最弱的蛇之后不会变成最弱的蛇，那么一定选择吃。

证明：

- 如果当前最强的蛇 A 吃了之后还是最强的蛇，那么显然选择吃；
- 否则，设 B 为下一条最强的蛇，
  - 若 B 选择不吃最弱的蛇，那么游戏结束，A 存活；
  - 若 B 吃，则由于 B 吃的蛇比 A 吃的弱，并且 A 比 B 强，可以得出吃了之后 B 仍然比 A 弱，由于 B 选择吃的时候确保自己不会被吃，所以 A 也一定不会被吃。

接下来分类讨论，最强的蛇 A 吃掉最弱的蛇之后会不会成为最弱的蛇。

- 如果不会，那么一定吃，继续模拟即可。
- 如果会，设下一个最强的蛇为 B，如果 B 吃 A 不变为最弱的蛇，那么 A 最初必须选择不吃。否则 B 吃 A 变成最弱的蛇，这样模拟下去，直到最强的蛇吃掉后不变为最弱蛇，可以倒推出 A 是否吃。

时间复杂度 $O(n \log n)$。

考虑优化，用两个双端队列 $P,Q$ 维护当前的所有蛇，并且双端队列中的蛇按照升序排序。一开始把所有蛇都放在 $P$ 中，先模拟吃了之后不变为最弱蛇，每次取出最强的蛇和最弱的蛇，相减放入 $Q$ 中。根据上面的推理可以得出每次得到的蛇是升序的。取出最强的蛇只需判断 $P,Q$ 中结尾处的大小，由于吃了之后不变为最弱蛇，所以最弱蛇一定在 $P$ 中。

接下来考虑吃了变为最弱的蛇，这时候不需要维护新的双端队列，只需维护当前最弱的蛇即可。求出需要模拟几次之后根据次数奇偶性就可以求出被吃掉的蛇总数。

时间复杂度 $\Theta(n)$。
